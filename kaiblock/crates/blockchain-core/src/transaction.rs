use crate::types::*;
use crate::{BlockchainError, Result};
use blockchain_crypto::{Hash256, Address, PublicKey, Signature, hash::sha256};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;



///transaction input for utxo model
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct TransactionInput {
	///reference to previous transaction output
	pub prev_output: OutPoint,
	///script signature to unlock utxo
	pub script_sig: Signature,
	///public key of the sender
	pub public_key: PublicKey,
	///sequence number(for time-locked transactions)
	pub sequence: i32,
}


impl TransactionInput {
	// add code here
	pub fn new(
		prev_output: OutPoint,
		signature: Signature,
		public_key: PublicKey,
		) -> Self {
		Self {
			prev_output,
			script_sig: Vec::new(),
			signature,
			public_key,
			sequence: 0xFFFFFFFF, //NO TIME LOCK
		}
	}
}


#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct TransactionOutput {
	///amount of cryptocurrency
	pub amount: Amount,
	///locking script
	pub script_pubkey: Script,
	///Recipient address (derived from script)
	pub address: Address,
}


impl TransactionOutput{
	pub fn new(amount:Amount, address: Address) -> Self {
		///create a simple p2pkh script from address
		let address_hash = sha256(address.data());

		Self {
			amount,
			script_pubkey: Script::pay_to_pubkey_hash(address_hash),
			address,
		}
	}
}


//=================UTXO===================

///utxo (unspent transaction output)
// For example, imagine that 1 BTC is a bucket full of coins. 
// Each coin represents a UTXO. If you purchase something from 
// Bob for .5 BTC, the network will give Bob the entire bucket 
// of coins and send back the .5 BTC you're owed in "change." 
// You now have a UTXO worth .5 BTC that cannot be divided into 
// smaller amounts.

// --->>>investopedia.com
// An unspent transaction output (UTXO) 
// is the amount of digital currency that remains after a 
// cryptocurrency transaction. You can think of it as the change 
// you receive after buying an item, but it is not a lower 
// denomination of the currency—it is a transaction output in 
// the database generated by the network to allow for non-exact 
// change transactions. 

//  The Network's Perspective on UTXO Transactions

// Nearly all transactions create UTXOs because the network 
// must "gather" a user's unspent outputs and send them to the 
// recipient. Thus, it's rare for a user to have the exact amount 
// of UTXO needed. This is similar to looking under the car seat 
// for loose change to pay for the burger at the drive-through 
// and finding a quarter when you only needed a dime—the restaurant 
// must give you back $.15. 

// When you initiate a transaction through your wallet, 
// UTXOs with your information are located and unlocked. 
// The new owner's information is associated with the UTXO 
// you transferred to them. They are locked once again, and 
// the user can use them in transactions via the same process.


#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct UTXO{
	///the transaction outpub
	pub output: TransactionOutput,

	///block height where this utxo is was created
	pub block_height: BlockHeight,

	///whether this utxo is coinbase
	pub is_coinbase: bool,

	///transaction id that created this utxo
	pub tx_id: TxId,

	///output index in the transaction
	pub output_index: u32,

}


impl UTXO {
	pub fn new(
		output: TransactionOutput,
		block_height: BlockHeight,
		tx_id: TxId,
		output_index: u32,
		is_coinbase: bool,
		) -> Self {
		Self{
			output,
			block_height,
			tx_id,
			output_index,
			is_coinbase,
		}
	}


	///get the outpoint for this utxo
	pub fn outpoint(&self) -> OutPoint {
		OutPoint::new(self.tx_id, self.output_index)
	}
}


/// Main transaction structure
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct Transaction {
	///tranaction version
	pub version: u32,
	///transaction inputs(utxo model)
	pub inputs: Vec<TransactionInput>,
	///transaction outputs (utxo model)
	pub outputs: Vec<TransactionOutput>,
	///lock time(when transaction can be included)
	pub lock_time: u32,
	///transaction fee
	pub fee: Fee,
	//transaction type
	pub tx_type: TransactionType,
	///timestamp when transaction was created
	pub timestamp: Timestamp,


	///nonce for account-based model
	pub nonce: Option<Nonce>,
	///sender address for account model
	pub from: Option<Address>,
	///reciepient addredd for simple tramsfers
	pub to: Option<Address>,
	///amount for simple transfers
	pub amount: Option<Amount>,
	///gas limit for smart contracts
	pub gas_limit : Option<Gas>,
	///gas price for smart contracts
	pub gas_price: Option<GasPrice>,
	/// transaction data/payload
	pub data: Vec<u8>
}


impl Transaction {
	///create a new utxo-style transaction
	pub fn new_utxo(
		inputs: Vec<TransactionInput>,
		outputs: Vec<TransactionOutput>,
		fee: Fee,
		) -> Self {
		Self{
			version: 1,
			inputs,
			outputs,
			lock_time: 0,
			fee,
			tx_type: TransactionType::Transfer,
			timestamp: Timestamp::now(),
			nonce: None,
			from: None,
			to: None,
			amount: None,
			gas_limit: None,
			gas_price: None,
			data: Vec::new(),
		}
	}

	///create a new accoun based transaction
	pub fn new_account(
		from: Address,
		to: Address,
		amount: Amount,
		nonce: Nonce,
		gas_limit: Gas,
		gas_price:  GasPrice,
		data: Vec<u8>,
		) -> Self {
		Self{
			version: 1,
			inputs: Vec::new(),
			outputs:: Vec::new(),
			lock_time: 0,
			fee: 0, //calculates from gas
			tx_type: if data.is_empty(){
				TransactionType::Transfer
			}else{
				TransactionType::ContractCall
			},
			timestamp: Timestamp::now(),
			nonce: Some(nonce),
			from: Some(from),
			to: Some(to),
			amount: Some(amount),
			gas_limit: Some(gas_limit),
			gas_price: Some(gas_price),
			data,

		}
	}

	///calculate transaction hash
	pub fn hash(&self) -> Hash256 {
		let serialized = self.serialize_for_hash();
		sha256(&serialized)
	}

	///Get transaction ID
	pub fn id(&self) -> TxId {
		TxId::new(self.hash())
	}


	///serialize transaction for hashing(excluding signatures)
	fn serialize_for_hash(&self) -> Vec<u8> {
		///create a copy without signatures for hasjing
		let mut tx_for_hash = self.clone();

		//clear signatres in inputs
		for input in &mut tx_for_hash.inputs {
			input.signature = Signature::from_bytes([0u8;64]);
			input.script_sig.clear();

		}
		bincode::serialize(&tx_for_hash).unwrap_or_default()
	}


	///get total input amount {utxo model}
	pub fn total_input_amount(&self, utxo_set: &HashMap<OutPoint, UTXO>) -> Result<Amount> {
		let mut total = 0u64;

		for input in &self.inputs {
			if let Some(utxo) = utxo_set.get(&input.prev_output){
				total = total.checked_add(utxo.output.amount)
					.ok_or_else(|| BlockchainError::InvalidTransaction("Amount overflow".to_string()))?;

			}else{
				return Err(BlockchainError::InvalidTransaction(
					format!("utxo not found: {}", input.prev_output)));
			}
		}

		ok(total)
	}


	///get total output amount
	pub fn total_output_amount(&self) -> Result<Amount> {
		let mut total = 0u64;
		for output in self.outputs {
			total = total.checked_add(output.amount)
				.ok_or_else(|| BlockchainError::InvalidTransaction("Amount overflow".to_string()))

		}


		///Add a simple amount for account based transactions
		if let Some(amount) = self.amount{
			total = total.checked_add(amount)
				.ok_or_else(|| BlockchainError::InvalidTransaction("Amount overflow".to_string()))
		}

		Ok(total)
	}



	///calculate transaction fee for account model
	pub fn calculate_gas_fee(&self) -> Fee {
		if let (Some(gas_limit), Some(gas_price)) = (self.gas_limit, self.gas_price) {
			gas_limit * gas_price
		}els {
			self.fee
		}
	}

	///check if transaction is coinbase
	pub fn is_coinbase(&self) -> bool{
		self.tx_type = TransactionType::Coinbase
	}


	///get transaction size in bytes
	pub fn size(&self) -> usize{
		bincode::serialize(self)
			.map(|data| data.len())
			.unwrap_or(0)
	}


	///verify transaction signatures
	pub fn verify_signature(&self, utxo_set: &HashMap<OutPoint, UTXO>) -> Result<bool> {
		//skip signature verification for coinbase
		if self.is_coinbase() {
			return Ok(true);
		}
		let tx_hash = self.hash();

		//verify utxo input signatures
		for input in &self.inputs{
			//erify that the public key can spend utxo
			if let Some(utxo) = utxo_set.get(&input.prev_output) {

				//for p2pkh, verify the public key hashed matches
				if let Script::PayToPubKeyHash(expected_hash) = &utxo.output.script_pubkey{
					let pubkey_hash = sha256(&input.public_key.to_bytes());
					if pubkey_hash != *expected_hash{
						return Ok(false);
					}
				}

				//verify signature
				if !input.public_key.verify(tx_hash.as_bytes(), &input.signature){
					return Ok(false);
				}
			}else {
				return Err(BlockchainError:;InvalidTransaction(
					format!("UTXO not found: {}", input.prev_output)
					));
			}
		}
		Ok(true)
	}

}


/// Transaction builder for easier construction
pub struct TransactionBuilder {
    version: u32,
    inputs: Vec<TransactionInput>,
    outputs: Vec<TransactionOutput>,
    fee: Fee,
    tx_type: TransactionType,
    from: Option<Address>,
    to: Option<Address>,
    amount: Option<Amount>,
    nonce: Option<Nonce>,
    gas_limit: Option<Gas>,
    gas_price: Option<GasPrice>,
    data: Vec<u8>,
}



impl TransactionBuilder {
    pub fn new() -> Self {
        Self {
            version: 1,
            inputs: Vec::new(),
            outputs: Vec::new(),
            fee: 0,
            tx_type: TransactionType::Transfer,
            from: None,
            to: None,
            amount: None,
            nonce: None,
            gas_limit: None,
            gas_price: None,
            data: Vec::new(),
        }
    }

    pub fn add_inputs(mut self, input: TransactionInput) -> Self{
    	self.inputs.push(input);
    	self
    }


    pub fn add_output(mut self, output: TransactionOutput) -> Self {
    	self.outputs.push(output);
    	self
    }
pub fn fee(mut self, fee: Fee) -> Self {
        self.fee = fee;
        self
    }
    
    pub fn from(mut self, from: Address) -> Self {
        self.from = Some(from);
        self
    }
    
    pub fn to(mut self, to: Address) -> Self {
        self.to = Some(to);
        self
    }
    
    pub fn amount(mut self, amount: Amount) -> Self {
        self.amount = Some(amount);
        self
    }
    
    pub fn nonce(mut self, nonce: Nonce) -> Self {
        self.nonce = Some(nonce);
        self
    }
    
    pub fn gas(mut self, gas_limit: Gas, gas_price: GasPrice) -> Self {
        self.gas_limit = Some(gas_limit);
        self.gas_price = Some(gas_price);
        self
    }
    
    pub fn data(mut self, data: Vec<u8>) -> Self {
        self.data = data;
        self
    }
    
    pub fn tx_type(mut self, tx_type: TransactionType) -> Self {
        self.tx_type = tx_type;
        self
    }


    pub fn build(self) -> Transaction {
    	Transaction{
    		version: self.version,
    		inputs: self.inputs,
    		outputs: self.outputs,
    		lock_time: 0,
    		fee: self.fee,
    		tx_type: self.tx_type,
    		timestamp: Timestamp::now(),
    		nonce: self.nonce,
    		from: self.from,
    		to: self.to,
    		amount: self.amount,
    		gas_limit: self.gas_limit,
    		gas_price: self.gas_price,
    		data: self.data,
    	}
    }
}


// /////////////////===================tests==============\\\\\\\\\\\\\\\\\\\\\\\\\\ \\

#[cfg(test)]
mod tests {
    use super::*;
    use blockchain_crypto::{signature::generate_keypair, address::public_key_to_address, AddressType};

    #[test]
    fn test_utxo_transaction_creation() {
        let keypair = generate_keypair();
        let address = public_key_to_address(keypair.public_key(), AddressType::Base58);
        
        // Create a simple UTXO transaction
        let prev_tx_id = TxId::new(sha256(b"previous tx"));
        let outpoint = OutPoint::new(prev_tx_id, 0);
        
        let input = TransactionInput::new(
            outpoint,
            Signature::from_bytes([1u8; 64]),
            *keypair.public_key(),
        );
        
        let output = TransactionOutput::new(100, address);
        
        let tx = Transaction::new_utxo(vec![input], vec![output], 10);
        
        assert_eq!(tx.from, Some(from_addr));
        assert_eq!(tx.to, Some(to_addr));
        assert_eq!(tx.amount, Some(100));
        assert_eq!(tx.nonce, Some(1));
        assert_eq!(tx.calculate_gas_fee(), 21000 * 20);
    }

    #[test]
    fn test_coinbase_transaction() {
        let keypair = generate_keypair();
        let address = public_key_to_address(keypair.public_key(), AddressType::Base58);
        
        let tx = Transaction::new_coinbase(address, 5000000000, 1); // 50 coins reward
        
        assert!(tx.is_coinbase());
        assert_eq!(tx.inputs.len(), 0);
        assert_eq!(tx.outputs.len(), 1);
        assert_eq!(tx.outputs[0].amount, 5000000000);
    }

    #[test]
    fn test_transaction_builder() {
        let keypair1 = generate_keypair();
        let keypair2 = generate_keypair();
        let from_addr = public_key_to_address(keypair1.public_key(), AddressType::Base58);
        let to_addr = public_key_to_address(keypair2.public_key(), AddressType::Base58);
        
        let tx = TransactionBuilder::new()
            .from(from_addr)
            .to(to_addr)
            .amount(100)
            .fee(10)
            .nonce(1)
            .gas(21000, 20)
            .build();
        
        assert_eq!(tx.from, Some(from_addr));
        assert_eq!(tx.to, Some(to_addr));
        assert_eq!(tx.amount, Some(100));
        assert_eq!(tx.fee, 10);
    }

    #[test]
    fn test_transaction_hash_consistency() {
        let keypair = generate_keypair();
        let address = public_key_to_address(keypair.public_key(), AddressType::Base58);
        
        let tx1 = Transaction::new_coinbase(address, 100, 1);
        let tx2 = Transaction::new_coinbase(address, 100, 1);
        
        // Same transactions should have same hash (deterministic)
        assert_eq!(tx1.hash(), tx2.hash());
        assert_eq!(tx1.id(), tx2.id());
    }

    #[test]
    fn test_utxo_creation() {
        let keypair = generate_keypair();
        let address = public_key_to_address(keypair.public_key(), AddressType::Base58);
        let output = TransactionOutput::new(100, address);
        let tx_id = TxId::new(sha256(b"test tx"));
        
        let utxo = UTXO::new(output.clone(), 1, tx_id, 0, false);
        
        assert_eq!(utxo.output, output);
        assert_eq!(utxo.block_height, 1);
        assert_eq!(utxo.tx_id, tx_id);
        assert_eq!(utxo.output_index, 0);
        assert!(!utxo.is_coinbase);
        assert_eq!(utxo.outpoint(), OutPoint::new(tx_id, 0));
    }
}.inputs.len(), 1);
        assert_eq!(tx.outputs.len(), 1);
        assert_eq!(tx.fee, 10);
        assert!(!tx.hash().is_zero());
    }

    #[test]
    fn test_account_transaction_creation() {
        let keypair1 = generate_keypair();
        let keypair2 = generate_keypair();
        let from_addr = public_key_to_address(keypair1.public_key(), AddressType::Base58);
        let to_addr = public_key_to_address(keypair2.public_key(), AddressType::Base58);
        
        let tx = Transaction::new_account(
            from_addr,
            to_addr,
            100,
            1, // nonce
            21000, // gas limit
            20, // gas price
            vec![], // no data
        );
    }
}